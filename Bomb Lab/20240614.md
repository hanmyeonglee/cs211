<style>
    html {
        font-family: Arial, Helvetica, sans-serif;
        font-size: 11pt;
    }
</style>

# BombLab Report

## Profile

- 날짜: 2025.10.15
- 학번: 20240614
- 이름: 이종원

## Binary Structure

### 1. main

```c
int main(int argc, char *argv[])
{
    ...
    initialize_bomb();
    ...
    input = read_line();
    phase_1(input);
    phase_defused();
    ...
}
```

메인 함수는 주어졌으며, 그중 중요한 함수는 다음과 같다:
1. initialize_bomb
2. phase_1 - phase_6
3. phase_defused

### 2. initialize_bomb

`initialize_bomb` 함수의 동작을 분석하지는 않았지만, 함수 이름으로 추정하건대 현재 컴퓨터의 hostname을 받아 저장된 값과 비교하여 프로그램의 실행 여부를 결정하는 동작을 하는 것으로 보인다.  
만약 이 함수가 실행되지 않는다면 `init_driver`도 실행되지 않는다.

그러나 `init_driver`의 동작은 주로 로컬 서버에 연결하는 것으로 보이며, 프로그램 실행에는 문제가 없을 것으로 판단된다.

### 3. phase_1 - phase_6

각 phase에서 공통적으로 나타난 부분은 `explode_bomb` 함수이다.

`explode_bomb`는 짧은 함수로, 몇 가지 출력과 결과를 서버에 전송하는 로직이 있다.

### 4. phase_defused

`phase_defused`는 초기에 결과를 서버에 전송하는 `send_msg`를 호출한다.  
그러나 이후로 `sscanf`로 `input_strings`의 특정 부분으로부터 `"%d %d %s"`에 맞는 입력을 받는다.  
이후 `esi`에 비교할 문자열 주소를 설정하고 `%s` 부분에 할당된 문자열과 비교하여 같으면 `secret_phase`를 호출한다.  
여기서 `input_strings`란 이름으로 보아 사용자 입력을 저장하는 곳이라고 추측할 수 있다.

### 4-1. read_line

구체적인 동작 방식은 분석하지 않았으나, 최종적으로 rdi에 `num_input_strings` 값의 80(= (1 + 4) << 4)배의 값을 설정하고 0x6047c0를 더한다는 것을 알 수 있다.  
여기서 0x6047c0는 `0x6048b0 <input_strings+240>`에서 추측할 수 있듯이 `0x6048b0 - 240`의 값으로 `input_strings`의 시작 주소이다.  
`num_input_strings`가 받은 문자열 개수라고 한다면, 각 문자열은 총 80 bytes의 버퍼를 가지고 설정된다는 것을 알 수 있다.  
이때 240은 80의 3배이므로 4번째 입력이다. 그렇다면 `secret_phase`를 가기 위한 문자열을 입력하는 것은 입력 4번째 줄이라는 것을 알 수 있다.

## Preprocess

1. initialization  
프로그램을 실행하기 위해서는 서버에서 동작시켜야 하지만, 그것은 잘못하면 터질 수도 있기 때문에 위험하다.  
분석한 바에 따르면 `initialize_bomb` 함수는 서버 연결과 프로그램 실행 여부 결정 이외의 특별한 행동을 하지 않는다.  
따라서 `initialize_bomb`를 호출하는 부분을 없애야만 로컬 컴퓨터에서 프로그램을 실행할 수 있을 것이다.

2. call <send_msg>  
다음으로 중요한 점은 `send_msg`를 통한 서버로의 전송이다.  
서버 연결이 안된다면 `send_msg`도 동작하지 않을 것으로 예상되나, 혹시 모르니 이 부분도 breakpoint가 아닌 아예 지우고 작업하는 것이 안전하다고 판단된다.

이 두 부분은 `nop` 연산으로 덮어씌운 후 기존 프로그램은 백업해놓고 주석처리 된 프로그램으로 분석할 수 있다.

## Problems

### Phase 1

#### Input Solution

> `I am for medical liability at the federal level.`

#### Pseudocode

```py
string = input()
if string != "I am for medical liability at the federal level.": explode_bomb()
```

#### Analyze

```
gef➤  x/s 0x4024a0
0x4024a0:       "I am for medical liability at the federal level."
```
첫 번째 phase이다.  
단순히 `0x4024a0`에 저장된 값을 받은 input과 비교하여 `eax` 값이 0이라면(서로 같다면) 통과한다.  
따라서 답은 문자열 그대로이다.

### Phase 2

#### Input Solution

> `1 2 4 8 16 32`

#### Pseudocode

```py
nums = list(map(int, input().split()))
if len(nums) < 6: explode_bomb()

for i in range(len(nums) - 1):
    n1, n2 = nums[i], nums[i+1]
    if 2 * n1 != n2: explode_bomb()
```

#### Analyze

```
gef➤  x/6wx $rsp
0x7fffffffd9d0: 0x00000001      0x00000002      0x00000004      0x00000008
0x7fffffffd9e0: 0x00000010      0x00000020
```
`read_six_numbers`로 6개 숫자를 입력받고, 각 숫자에 대한 조건을 검사하는 함수이다.  
처음에 rsi에 `rsp - 0x28`을 설정하였으므로 스택에 총 6개의 숫자를 적는다는 것을 알 수 있다.  
실제로 사용자 입력을 넣어서 확인해보면(`1 2 4 8 16 32`) 스택 위에서부터 6개의 int값이 저장된 것을 확인할 수 있다.  
해당 시점에서 rbx에는 배열 주소가 있고 int 배열이기 때문에 4씩 증가하면서 각 원소들을 얻는다.  
다만 eax에는 `rbx - 0x4`의 원소, 즉 현재 원소 직전의 원소의 값의 두 배가 할당된다.  
그리고 그것을 cmp를 통해 현재 원소 값과 비교하므로, 각 원소의 관계는 공비가 2인 등비수열이어야 한다는 것을 알 수 있다.  
따라서 답은 int로 표현할 수 있는 0이 아닌 공비가 2인 등비수열이다.

### Phase 3

#### Input Solution

> `0 247`

#### Pseudocode

```py
a, b = map(int, input().split())
match a:
    case 0: target = 247
    case 1: target = 880
    case 2: target = 336
    case 3: target = 555
    case 4: target = 417
    case 5: target = 853
    case 6: target = 91
    case 7: target = 601
    case _: explode_bomb()

if b != target: explode_bomb() 
```

#### Analyze

```
gef➤  x/8gx 0x402500
0x402500:       0x0000000000400f8c      0x0000000000400fc9
0x402510:       0x0000000000400f93      0x0000000000400f9a
0x402520:       0x0000000000400fa1      0x0000000000400fa8
0x402530:       0x0000000000400faf      0x0000000000400fb6
```
이 phase에서는 input에서 `"%d %d"` 형식으로 int 2개를 받아서 비교하는 방식을 사용한다.  
입력 받은 숫자는 스택(`rsp+0x8`, `rsp+0xc`)에 순서대로 저장되어 있으며, 그 값을 eax에 저장하여 `0x402500`에 있는 주소 배열을 통해 조건을 검사하는 switch문이 있다.  
이때 각 주소는 eax에 값을 설정하고 `*phase_3 + 123`으로 jmp하는 코드이므로, 첫 번째 숫자는 0-7의 숫자란 것을 알 수 있다.  
이후 eax에 설정된 값은 두 번째 입력 받은 값(`rsp + 0x8`)과 비교된다.  
이때 서로 같다면 성공이므로, 0-7과 eax 할당된 값 쌍 8종 중 아무거나 입력하면 된다.

### Phase 4

#### Input Solution

> `7 7`

> `7 7 DrJisungPark` (`secret_phase`에서 설명할 예정)

#### Pseudocode

```py
a, b = map(int, input().split())
if a > 14: explode_bomb()

def func4(n, low, high):
    mid = (low + high) // 2
    
    if n < mid:
        return mid + func4(n, low, mid - 1)
    elif n > mid:
        return mid + func4(n, mid + 1, high)

    return mid

result = func4(a, 0, 14)
if result != 7 or b != 7:
    explode_bomb()
```

#### Analyze

이 phase에서는 input에서 `"%d %d"` 형식으로 int 2개를 받아서 비교하는 방식을 사용한다.  
각 int는 스택(`rsp+0x8`, `rsp+0xc`)에 저장되고, 첫 번째 값은 0, 14와 함께 `func4` 함수로 전달되어서 어떤 값을 반환하고, 두 번째 값은 나중에 검사한다.  
이때 반환값과 두 번째 값 모두 `7`이어야 한다.

`func4`는 재귀 함수이다. 중간에 자기 자신을 호출하는 부분이 존재한다.  
각 arguments는 calling convention에 따라 rdi, rsi, rdx에 각각 저장되었으며, 따라서 초반 eax에 계산되어 저장된 값은 2, 3번째 인자의 정수 평균이다.  
이후 첫 번째 인자와 평균값을 비교하여,
1. 크다면 세 번째 인자를 평균 - 1로 설정하고 func4를 호출한 후, 그 값을 첫 번째 인자와 더한 값을 반환한다.
2. 작다면 두 번째 인자를 평균 + 1로 설정하고 func4를 호출한 후, 그 값을 첫 번째 인자와 더한 값을 반환한다.
3. 같다면 그냥 첫 번째 인자의 값을 반환한다.

이때 반환값은 7이어야 하고, 2, 3번째 인자는 각각 0, 14였으므로 평균은 7이다.  
따라서 입력은 7을 주면 된다.

### Phase 5

#### Input Solution

> `5 115`

#### Pseudocode

```py
L = 10, 2, 14, 7, 8, 12, 15, 11, 0, 4, 1, 13, 3, 9, 6, 5

a, b = map(int, input().split())
b &= 0xF

if b == 0xF: explode_bomb()

x = y = 0
while b != 15:
    y += 1
    b = L[b]
    x += b

if y != 15 or a != x: explode_bomb()
```

#### Analyze

```
gef➤  x/16wd 0x402540
0x402540 <array.3161>:  10      2       14      7
0x402550 <array.3161+16>:       8       12      15      11
0x402560 <array.3161+32>:       0       4       1       13
0x402570 <array.3161+48>:       3       9       6       5
```
이 phase에서는 input에서 `"%d %d"` 형식으로 int 2개를 받아서 스택(`rsp+0x8`, `rsp+0xc`)에 저장 후 비교한다.  
eax에 첫 번째로 받은 값을 할당한 후 `& 0xF` 연산을 해서 저장하고, 그 값을 다시 0xF와 비교하여 0xF와 같다면 폭탄이 터진다.  
아니라면 ecx, edx를 통한 반복문에 진입한다.  
ecx는 accumulator, edx는 counter 역할을 하며, rax는 저장된 배열로부터 값을 받는 역할을 한다.  
rax는 `[rax*4+0x402540]`를 통해 저장된 배열인 `{10, 2, 14, 7, 8, 12, 15, 11, 0, 4, 1, 13, 3, 9, 6, 5}`에 rax를 index로 하여 접근하며, 얻은 값이 15가 될 때까지 반복한다.  
이때 반복하는 동안 ecx는 rax의 값이 계속 더해지며, edx는 한 번 반복할때마다 1씩 증가한다.  
최종적으로 얻어야 하는 값은 edx는 15여야 하며, 그 과정에서 얻은 모든 rax의 합인 ecx에 저장된 값과 두 번째로 입력 받은 값이 같아야 한다.  
15번째에 15에 접근해야하므로, 간단하게 역산이 가능하며 따라서 답은 `5 115`이다.

### Phase 6

#### Input Solution

> 6 3 1 4 2 5

#### Pseudocode

```py
nums = list(map(int, input().split()))
assert len(nums) == 6

if (
    any(num > 6 for num in nums) or
    len(set(nums)) < 6
):
    explode_bomb()

class Node:
    def __init__(self, id, val):
        self.id = id
        self.val = val
        self.next = None

node1 = Node(1, 0x24c)
cur = node1
for i, val in enumerate([0x354, 0x16d, 0x32e, 0x379, 0x11e], 2):
    cur.next = Node(i, val)
    cur = cur.next

nodes = []
for i in range(0, 24, 4):
    n = nums[i // 4]
    node = node1
    if n > 1:
        j = 1
        while j < n:
            node = node.next
            j += 1
    
    nodes.append(node)

for n1, n2 in zip(nodes[:-1], nodes[1:]):
    if n1.val > n2.val: explode_bomb()
```

#### Analyze

```
gef➤  x/12gx 0x6042f0
0x6042f0 <node1>:       0x000000010000024c      0x0000000000604300
0x604300 <node2>:       0x0000000200000354      0x0000000000604310
0x604310 <node3>:       0x000000030000016d      0x0000000000604320
0x604320 <node4>:       0x000000040000032e      0x0000000000604330
0x604330 <node5>:       0x0000000500000379      0x0000000000604340
0x604340 <node6>:       0x000000060000011e      0x0000000000000000
```
`read_six_numbers`로 스택에 6개 숫자를 입력받고, 숫자를 통해 LinkedList를 조작하는 함수이다.  
이 함수는 총 네 개의 반복문으로 구성되어있다.

첫 번째는 원소들의 조건을 검사하는 반복문이다.  
초기에 r13은 스택에 저장된 6개 수 배열 주소를 가지고, 반복될 때마다 하나씩 eax에 할당하며, r12d가 counter 역할을 한다.  
이때 eax에 1을 뺀 값이 5보다 큰 지 검사하며, 크다면 explode_bomb가 실행된다. 만약 작다면 한 번의 반복문이 더 실행된다.  
이 반복문에서는 현재 r12d의 값을 counter인 ebx에 저장하여 현재 원소의 index를 얻어 그 다음 index부터 끝까지 접근해 현재 원소 기준으로 뒤쪽에 있는 원소들 중 중복되는 값이 있는지 검사한다.  
있다면 explode_bomb하므로 원소들은 겹치지 않아야하며, 이 반복문에서 ebx가 5 이상이 된다면 종료되어 eax의 값을 1 늘려 다음 원소로 접근한 후 반복한다.  
즉, 여기서 얻을 수 있는 원소들의 조건은, 6 이하의 겹치치 않는 6개의 정수라는 것이다.

두 번째는 LinkedList를 저장하는 반복문이다.  
초기에 esi는 counter, ecx는 counter에 따라 입력 받은 원소들을 할당받는다.  
이때 ecx의 값이 1 이하라면 edx에 0x6042f0가 할당된다.
만약 아니라면 eax에 1이, edx에 0x6042f0가 할당되고, eax가 counter로 다시 반복문에 진입한다.  
해당 반복문은 rdx에 저장된 주소에서 8 바이트 이후에 저장된 값을 재할당하면서 eax의 값을 1씩 증가시킨다. 이때 eax가 ecx의 값과 같아지면 반복문은 종료된다.  
내부 반복문에서 얻은 rdx의 값은 `rsp+rsi*2`에 저장되며, rsi는 현재 counter이기에 스택에 배열로 특정 주소들을 저장하고 있다는 것을 알 수 있다.

이때 `0x6042f0`에 저장된 값이 무엇인지 분석할 수 있다.  
위의 출력 결과를 보면, 해당 주소에는 node1 - node6가 저장되어 있으며, 각 node들은 크게 세 부분으로 구성되는 듯 보인다.  
1. id 부분, 첫 4바이트
2. value 부분, 그 다음 4바이트
3. next 부분, 다음 node를 가리키는 주소를 저장하는 8바이트 공간
정리하자면, 이 node는 struct로 id, value, next를 저장하는 전형적인 LinkedList의 형태를 띄고 있으며, 순서대로 서로를 가리키고 있다.  
그러므로 두 번째 내부 반복문에서 "저장된 주소의 8바이트 이후 값"을 가져온다는 것은 다음 노드의 주소를 가져온다는 뜻이며, 이는 결국 입력 값이 만약 3이라면 node3을 가져오겠다는 말과 같다.  
이후 이를 순서대로 배열에 저장하므로, 1 - 6을 입력 받은 후 그 순서대로 node를 배열에 저장한다는 뜻이다.

세 번째는 입력 값과 아까 저장된 node 배열을 사용하는 반복문이다.  
초기에 rdx는 rax(=node 배열 + 1)의 주소를 받고, rcx는 rbx(=node 배열)의 값읗 받는다.  
이후 rcx는 node에 접근하여 8바이트 이후 주소에 rax의 주소를 저장한다.  
rax는 다음 node로 접근하기 위해 8바이트 증가하고, 이후 다시 rcx는 rdx의 값을 받아 반복한다.  
만약 rax가 입력값 주소(node 배열 다음 데이터)와 같아진다면 끝났다는 것을 의미하므로 종료한다.  
이 반복문은 저장된 순서대로 node의 next 주소를 재조합하여 LinkedList를 정렬한다.

마지막은 LinkedList 내부 값의 비교를 하는 반복문이다.  
초기에 ebp는 5가 저장되는 counter이며, ebp가 0이 되면 종료한다.  
rbx에는 root node의 주소가 할당되며, rax에는 rbx 주소에서 8 바이트 떨어진 주소, 즉 node의 next node의 주소가 할당된다.  
이 이후 각 노드의 값을 비교한다. 이때 각 rbx가 rax보다 크다면, 즉 수열이 감소한다면 explode_bomb가 작동한다.  
아니라면 ebp를 1 줄이고, rbx의 값을 next node의 주소로 바꾼다.  
여기서 알 수 있는 점은 최종 LinkedList가 오름차순으로 정렬되어 있어야 한다는 것이다.

각 노드의 값은 0x24c, 0x354, 0x16d, 0x32e, 0x379, 0x11e이다.  
노드는 입력한 숫자 순서대로 정렬되므로, 작은 node 번호부터 나열해야한다.  
따라서 이 때의 답은 `6 3 1 4 2 5`이다.

### Secret Phase

#### Input Solution

> `35`

#### Pseudocode

```py
def fun7(tree, i, number):
    if i >= len(tree): return -1

    N = tree[i]
    if N > number:
        return 2 * fun7(tree, 2 * i + 1, number)
    elif N < number:
        return 2 * fun7(tree, 2 * i + 2, number) + 1
    else:
        return 0

TREE = [0x24, 0x8, 0x32, 0x6, 0x16, 0x2d, 0x6b, 0x1, 0x7, 0x14, 0x23, 0x28, 0x2f, 0x63, 0x3e9]
# 실제로는 배열이 아니지만 편의상 배열로 pseudocode를 짬
n = int(input())
if n > 1001: explode_bomb()
if fun7(TREE, 0, n) != 6: explode_bomb()
```

#### Analyze

이 phase는 일반적으로는 접근할 수 없다. 그러나 phase_defused를 관찰하면 발견할 수 있다.

```
gef➤  x/s 0x6048b0
0x6048b0 <input_strings+240>:   "7 7"
gef➤  x/s 0x402820
0x402820:       "DrJisungPark"
```
아까 분석했듯이 0x6048b0 부분에 `%s`에 특정 문자열을 넣어야지만 `secret_phase`로 넘어갈 수 있다.  
`*phase_defused + 43`에 breakpoint를 걸고 살펴보면 `<input_strings+240>` 부분에는 `7 7`이 저장되어 있음을 알 수 있다.  
이때 `7 7`은 문제 4번의 답이었으므로 아까 분석과 맞게 4번째 답이 곧 `0x6048b0`에 저장된 값이라고 볼 수 있다.  
`secret_phase` 접근을 위해서는 `"DrJisungPark"`이라는 특정 문자열을 입력해야하고, 4번 문제의 format은 `%d %d`였기 때문에 그냥 `7 7` 뒤에 필요한 문자열을 한 칸 띄워서 입력하면 `%s` 부분에서 문자열을 입력할 수 있다.  
따라서 4번 문제에서 답을 `7 7`이 아닌 `7 7 DrJisungPark`이라고 하면 `secret_phase`에 진입할 수 있다.

이 함수의 동작 자체는 간단하다.  
추가로 한 줄을 받은 후 받은 문자열을 십진수로 전환하고, 그 값이 `1001`보다 크다면 폭탄을 터뜨린다.  
만약 그렇지 않다면 `0x604110`과 입력 받은 숫자를 인자로 주어 `fun7` 함수의 반환값을 받은 후 값을 비교한다.  
만약 6이라면 성공이고, 아니라면 폭탄이 터진다.

```
gef➤  x/60gx 0x604110
0x604110 <n1>:          0x0000000000000024      0x0000000000604130
0x604120 <n1+16>:       0x0000000000604150      0x0000000000000000
0x604130 <n21>:         0x0000000000000008      0x00000000006041b0
0x604140 <n21+16>:      0x0000000000604170      0x0000000000000000
0x604150 <n22>:         0x0000000000000032      0x0000000000604190
0x604160 <n22+16>:      0x00000000006041d0      0x0000000000000000
...
```
이 함수도 재귀함수이다. 이때 첫 번째 인자가 없다면 -1을 반환하고, 있다면 두 번째 인자와 비교한다.  
calling convention에 따라 rdi, rsi에 각각 인자가 있으며, rdi에는 특정 주소가 저장되어 있다.  
이때 만약 그 주소에 저장된 값이 rsi보다 크다면 `rdi + 8`에 있는 주소를 첫 번째 인자로 바꾸어 fun7를 재호출 한 후 그 반환값의 두 배를 다시 반환한다.  
만약 rsi보다 작다면 이번엔 두 번째 인자는 `rdi + 16`으로 주소를 바꾸어 fun7을 재호출 한 후 반환값의 두 배에 1을 더한 값을 반환한다.  
rsi와 같다면 0을 반환한다.

이때 가장 초기에 인자로 전달된 `0x604110`에 무엇이 저장되어있는지 알아야 한다.  
구조와 이름을 통해 쉽게 예측할 수 있는데, 이는 이진 트리이다.  
첫 번째 8바이트는 값, 두, 세번째 8바이트는 left, right child의 주소이다.  
이를 그래프로 표현하면 다음과 같다.

<p align="center"><img src="graph.png" alt="Constraint Graph Image" width="500px" style="margin: 0 auto"></p>

다만 중요한 점은 이 함수의 반환값은 트리에 저장된 값과는 전혀 상관이 없다.  
최종 답이 6이 되어야 한다는 것은 곳 특정한 path를 따라가야 한다는 것을 의미한다.  
6은 짝수이므로, 그 전에는 반드시 rdi > rsi여야 한다. 그 전에는 3이므로 rdi < rsi이여야 하고, 그 전은 1이여야 하기 때문에 rdi < rsi여야 한다.  
이렇게 되면 총 4개의 node를 거치므로 특정 path를 알 수 있다. 순서대로 정렬하면 다음과 같다:
`left -> right -> equal`
이때 이 순서대로 숫자를 나열하면 `{0x24, 0x8, 0x16, 0x23}`이므로 입력값의 조건을 알 수 있다.  
따라서 답은 0x23이다.