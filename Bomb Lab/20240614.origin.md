<style>
    html {
        font-family: Arial, Helvetica, sans-serif;
        font-size: 11pt;
    }
</style>

# BombLab Report

## Profile

- 날짜: 2025.10.15
- 학번: 20240614
- 이름: 이종원

## Binary Structure

### 1. main

```c
int main(int argc, char *argv[])
{
    ...
    initialize_bomb();
    ...
    input = read_line();
    phase_1(input);
    phase_defused();
    ...
    phase_2(input); // same processes(read_line, phase_defused)
    ...
    phase_3(input); // same processes(read_line, phase_defused)
    ...
    phase_4(input); // same processes(read_line, phase_defused)
    ...
    phase_5(input); // same processes(read_line, phase_defused)
    ....
    phase_6(input); // same processes(read_line, phase_defused)

    return 0;
}
```

메인 함수는 주어졌으며, 그중 중요한 함수는 다음과 같다:
1. initialize_bomb
2. phase_1 - phase_6
3. phase_defused

### 2. initialize_bomb

```asm
Dump of assembler code for function initialize_bomb:
...
0x000000000040137b <+36>:    call   0x400c60 <gethostname@plt>
...
0x00000000004013fe <+167>:   call   0x4020a1 <init_driver>
...
```
`initialize_bomb` 함수의 동작을 분석하지는 않았지만, 함수 이름으로 추정하건대 현재 컴퓨터의 hostname을 받아 저장된 값과 비교하여 프로그램의 실행 여부를 결정하는 동작을 하는 것으로 보인다.  
만약 이 함수가 실행되지 않는다면 `init_driver`도 실행되지 않는다.

```asm
Dump of assembler code for function init_driver:
0x00000000004020b4 <+19>:    call   0x400bc0 <signal@plt>
...
0x00000000004020e6 <+69>:    call   0x400cc0 <socket@plt>
...
0x0000000000402145 <+164>:   call   0x400bd0 <gethostbyname@plt>
...
0x00000000004021f4 <+339>:   call   0x400c90 <connect@plt>
```
```
gef➤  x/s 0x40282d
0x40282d:       "127.0.0.1"
```
그러나 `init_driver`의 동작은 주로 로컬 서버에 연결하는 것으로 보이며, 프로그램 실행에는 문제가 없을 것으로 판단된다.

### 3. phase_1 - phase_6

```asm
Dump of assembler code for function phase_1:
...
0x0000000000400f02 <+18>:    call   0x401554 <explode_bomb>
...
```
각 phase에서 공통적으로 나타난 부분은 `explode_bomb` 함수이다.

```asm
Dump of assembler code for function explode_bomb:
...
0x0000000000401571 <+29>:    call   0x401490 <send_msg>
...
```
`explode_bomb`는 짧은 함수로, 몇 가지 출력과 결과를 서버에 전송하는 로직이 있다.

### 4. phase_defused

```asm
Dump of assembler code for function phase_defused:
...
0x0000000000401700 <+14>:    cmp    DWORD PTR [rip+0x203095],0x6        # 0x60479c <num_input_strings>
...
0x0000000000401718 <+38>:    mov    esi,0x402817
0x000000000040171d <+43>:    mov    edi,0x6048b0
...
0x0000000000401727 <+53>:    call   0x400c30 <__isoc99_sscanf@plt>
...
0x000000000040173b <+73>:    call   0x4012ee <strings_not_equal>
...
0x000000000040175d <+107>:   call   0x401204 <secret_phase>
...
```
```
gef➤  x/s 0x402817
0x402817:       "%d %d %s"
gef➤  x/s 0x6048b0
0x6048b0 <input_strings+240>:   ""
gef➤  x/s 0x402820
0x402820:       "DrJisungPark"
```
`phase_defused`는 초기에 결과를 서버에 전송하는 `send_msg`를 호출한다.  
그러나 이후로 `sscanf`로 `input_strings`의 특정 부분으로부터 `"%d %d %s"`에 맞는 입력을 받는다.  
이후 `esi`에 비교할 문자열 주소를 설정하고 `%s` 부분에 할당된 문자열과 비교하여 같으면 `secret_phase`를 호출한다.  
여기서 `input_strings`란 이름으로 보아 사용자 입력을 저장하는 곳이라고 추측할 수 있다.

### 4-1. read_line

```asm
Dump of assembler code for function read_line:
...
0x000000000040164d <+129>:   mov    edx,DWORD PTR [rip+0x203149]        # 0x60479c <num_input_strings>
0x0000000000401653 <+135>:   movsxd rax,edx
0x0000000000401656 <+138>:   lea    rsi,[rax+rax*4]
0x000000000040165a <+142>:   shl    rsi,0x4
0x000000000040165e <+146>:   add    rsi,0x6047c0
0x0000000000401665 <+153>:   mov    rdi,rsi
...
```
구체적인 동작 방식은 분석하지 않았으나, 최종적으로 rdi에 `num_input_strings` 값의 80(= (1 + 4) << 4)배의 값을 설정하고 0x6047c0를 더한다는 것을 알 수 있다.  
여기서 0x6047c0는 `0x6048b0 <input_strings+240>`에서 추측할 수 있듯이 `0x6048b0 - 240`의 값으로 `input_strings`의 시작 주소이다.  
`num_input_strings`가 받은 문자열 개수라고 한다면, 각 문자열은 총 80 bytes의 버퍼를 가지고 설정된다는 것을 알 수 있다.  
이때 240은 80의 3배이므로 4번째 입력이다. 그렇다면 `secret_phase`를 가기 위한 문자열을 입력하는 것은 입력 4번째 줄이라는 것을 알 수 있다.

## Preprocess

### 1. initialization

프로그램을 실행하기 위해서는 서버에서 동작시켜야 하지만, 그것은 잘못하면 터질 수도 있기 때문에 위험하다.  
분석한 바에 따르면 `initialize_bomb` 함수는 서버 연결과 프로그램 실행 여부 결정 이외의 특별한 행동을 하지 않는다.  
따라서 `initialize_bomb`를 호출하는 부분을 없애야만 로컬 컴퓨터에서 프로그램을 실행할 수 있을 것이다.

### 2. call <send_msg>

다음으로 중요한 점은 `send_msg`를 통한 서버로의 전송이다.  
서버 연결이 안된다면 `send_msg`도 동작하지 않을 것으로 예상되나, 혹시 모르니 이 부분도 breakpoint가 아닌 아예 지우고 작업하는 것이 안전하다고 판단된다.

### Preprocess Solution

```
0x0000000000400e2c <+111>:   call   0x401357 <initialize_bomb>
->
gef➤  x/5bx 0x0000000000400e2c
0x400e2c <main+111>:    0xe8    0x26    0x05    0x00    0x00
```
```
0x0000000000401571 <+29>:    call   0x401490 <send_msg>
->
gef➤  x/5bx 0x0000000000401571
0x401571 <explode_bomb+29>:     0xe8    0x1a    0xff    0xff    0xff
```
```
0x00000000004016fb <+9>:     call   0x401490 <send_msg>
->
gef➤  x/5bx 0x00000000004016fb
0x4016fb <phase_defused+9>:     0xe8    0x90    0xfd    0xff    0xff
```
다음과 같은 명령어를 통하여 `send_msg` call 부분만 얻을 수 있다.  
call은 1 byte operation이고 주소가 4 bytes로 표시되기 때문에 총 5 bytes를 읽는다.  
이후 이 부분은 `nop` 연산으로 덮어씌운 후 기존 프로그램은 백업해놓고 주석처리 된 프로그램으로 분석할 수 있다.

```py
import re

target1 = b'\xe8\x1a\xff\xff\xff' # call <send_msg> in explode_bomb
target2 = b'\xe8\x90\xfd\xff\xff' # call <send_msg> in phase_defused
target3 = b'\xe8\x26\x05\x00\x00' # call <initialize_bomb> in main
NOP = b'\x90' * 5 # NOP instruction in x86

binary = open('bomb', 'rb').read()
with open('bomb.back', 'wb') as f:
    f.write(binary)

assert len(re.findall(target1, binary)) == 1
assert len(re.findall(target2, binary)) == 1
assert len(re.findall(target3, binary)) == 1

binary = binary.replace(target1, NOP).replace(target2, NOP).replace(target3, NOP) # NOP

with open('bomb', 'wb') as f:
    f.write(binary)
```

## Problems

### Phase 1

#### Input Solution

> `I am for medical liability at the federal level.`

#### Pseudocode

```py
string = input()
if string != "I am for medical liability at the federal level.": explode_bomb()
```

#### Analyze

```asm
Dump of assembler code for function phase_1:
0x0000000000400ef0 <+0>:     sub    rsp,0x8
0x0000000000400ef4 <+4>:     mov    esi,0x4024a0
0x0000000000400ef9 <+9>:     call   0x4012ee <strings_not_equal>
0x0000000000400efe <+14>:    test   eax,eax
0x0000000000400f00 <+16>:    je     0x400f07 <phase_1+23>
0x0000000000400f02 <+18>:    call   0x401554 <explode_bomb>
0x0000000000400f07 <+23>:    add    rsp,0x8
0x0000000000400f0b <+27>:    ret
```
```
gef➤  x/s 0x4024a0
0x4024a0:       "I am for medical liability at the federal level."
```
첫 번째 phase이다.  
단순히 `0x4024a0`에 저장된 값을 받은 input과 비교하여 `eax` 값이 0이라면(서로 같다면) 통과한다.  
따라서 답은 문자열 그대로이다.

### Phase 2

#### Input Solution

> `1 2 4 8 16 32`

#### Pseudocode

```py
nums = list(map(int, input().split()))
if len(nums) < 6: explode_bomb()

for i in range(len(nums) - 1):
    n1, n2 = nums[i], nums[i+1]
    if 2 * n1 != n2: explode_bomb()
```

#### Analyze

```asm
Dump of assembler code for function phase_2:
0x0000000000400f0c <+0>:     push   rbp
0x0000000000400f0d <+1>:     push   rbx
0x0000000000400f0e <+2>:     sub    rsp,0x28
0x0000000000400f12 <+6>:     mov    rsi,rsp
0x0000000000400f15 <+9>:     call   0x40158a <read_six_numbers>
0x0000000000400f1a <+14>:    cmp    DWORD PTR [rsp],0x1
0x0000000000400f1e <+18>:    je     0x400f40 <phase_2+52>
0x0000000000400f20 <+20>:    call   0x401554 <explode_bomb>
0x0000000000400f25 <+25>:    jmp    0x400f40 <phase_2+52>
0x0000000000400f27 <+27>:    mov    eax,DWORD PTR [rbx-0x4]
0x0000000000400f2a <+30>:    add    eax,eax
0x0000000000400f2c <+32>:    cmp    DWORD PTR [rbx],eax
0x0000000000400f2e <+34>:    je     0x400f35 <phase_2+41>
0x0000000000400f30 <+36>:    call   0x401554 <explode_bomb>
0x0000000000400f35 <+41>:    add    rbx,0x4
0x0000000000400f39 <+45>:    cmp    rbx,rbp
0x0000000000400f3c <+48>:    jne    0x400f27 <phase_2+27>
0x0000000000400f3e <+50>:    jmp    0x400f4c <phase_2+64>
0x0000000000400f40 <+52>:    lea    rbx,[rsp+0x4]
0x0000000000400f45 <+57>:    lea    rbp,[rsp+0x18]
0x0000000000400f4a <+62>:    jmp    0x400f27 <phase_2+27>
0x0000000000400f4c <+64>:    add    rsp,0x28
0x0000000000400f50 <+68>:    pop    rbx
0x0000000000400f51 <+69>:    pop    rbp
0x0000000000400f52 <+70>:    ret
...
```
```
gef➤  x/6wx $rsp
0x7fffffffd9d0: 0x00000001      0x00000002      0x00000004      0x00000008
0x7fffffffd9e0: 0x00000010      0x00000020
```
`read_six_numbers`로 6개 숫자를 입력받고, 각 숫자에 대한 조건을 검사하는 함수이다.  
처음에 rsi에 `rsp - 0x28`을 설정하였으므로 스택에 총 6개의 숫자를 적는다는 것을 알 수 있다.  
실제로 사용자 입력을 넣어서 확인해보면(`1 2 4 8 16 32`) 스택 위에서부터 6개의 int값이 저장된 것을 확인할 수 있다.  
해당 시점에서 rbx에는 배열 주소가 있고 int 배열이기 때문에 4씩 증가하면서 각 원소들을 얻는다.  
다만 eax에는 `rbx - 0x4`의 원소, 즉 현재 원소 직전의 원소의 값의 두 배가 할당된다.  
그리고 그것을 cmp를 통해 현재 원소 값과 비교하므로, 각 원소의 관계는 공비가 2인 등비수열이어야 한다는 것을 알 수 있다.  
따라서 답은 int로 표현할 수 있는 0이 아닌 공비가 2인 등비수열이다.

### Phase 3

#### Input Solution

> `0 247`  
`1 880`  
`2 336`  
`3 555`  
`4 417`  
`5 853`  
`6 91`  
`7 601`

#### Pseudocode

```py
a, b = map(int, input().split())
match a:
    case 0: target = 247
    case 1: target = 880
    case 2: target = 336
    case 3: target = 555
    case 4: target = 417
    case 5: target = 853
    case 6: target = 91
    case 7: target = 601
    case _: explode_bomb()

if b != target: explode_bomb() 
```

#### Analyze

```asm
Dump of assembler code for function phase_3:
0x0000000000400f53 <+0>:     sub    rsp,0x18
0x0000000000400f57 <+4>:     lea    rcx,[rsp+0x8]
0x0000000000400f5c <+9>:     lea    rdx,[rsp+0xc]
0x0000000000400f61 <+14>:    mov    esi,0x4027cd
0x0000000000400f66 <+19>:    mov    eax,0x0
0x0000000000400f6b <+24>:    call   0x400c30 <__isoc99_sscanf@plt>
0x0000000000400f70 <+29>:    cmp    eax,0x1
0x0000000000400f73 <+32>:    jg     0x400f7a <phase_3+39>
0x0000000000400f75 <+34>:    call   0x401554 <explode_bomb>
0x0000000000400f7a <+39>:    cmp    DWORD PTR [rsp+0xc],0x7
0x0000000000400f7f <+44>:    ja     0x400fbd <phase_3+106>
0x0000000000400f81 <+46>:    mov    eax,DWORD PTR [rsp+0xc]
0x0000000000400f85 <+50>:    jmp    QWORD PTR [rax*8+0x402500]
0x0000000000400f8c <+57>:    mov    eax,0xf7
0x0000000000400f91 <+62>:    jmp    0x400fce <phase_3+123>
0x0000000000400f93 <+64>:    mov    eax,0x150
0x0000000000400f98 <+69>:    jmp    0x400fce <phase_3+123>
0x0000000000400f9a <+71>:    mov    eax,0x22b
0x0000000000400f9f <+76>:    jmp    0x400fce <phase_3+123>
0x0000000000400fa1 <+78>:    mov    eax,0x1a1
0x0000000000400fa6 <+83>:    jmp    0x400fce <phase_3+123>
0x0000000000400fa8 <+85>:    mov    eax,0x355
0x0000000000400fad <+90>:    jmp    0x400fce <phase_3+123>
0x0000000000400faf <+92>:    mov    eax,0x5b
0x0000000000400fb4 <+97>:    jmp    0x400fce <phase_3+123>
0x0000000000400fb6 <+99>:    mov    eax,0x259
0x0000000000400fbb <+104>:   jmp    0x400fce <phase_3+123>
0x0000000000400fbd <+106>:   call   0x401554 <explode_bomb>
0x0000000000400fc2 <+111>:   mov    eax,0x0
0x0000000000400fc7 <+116>:   jmp    0x400fce <phase_3+123>
0x0000000000400fc9 <+118>:   mov    eax,0x370
0x0000000000400fce <+123>:   cmp    eax,DWORD PTR [rsp+0x8]
0x0000000000400fd2 <+127>:   je     0x400fd9 <phase_3+134>
0x0000000000400fd4 <+129>:   call   0x401554 <explode_bomb>
0x0000000000400fd9 <+134>:   add    rsp,0x18
0x0000000000400fdd <+138>:   re
...
```
```
gef➤  x/s 0x4027cd
0x4027cd:       "%d %d"
gef➤  x/8gx 0x402500
0x402500:       0x0000000000400f8c      0x0000000000400fc9
0x402510:       0x0000000000400f93      0x0000000000400f9a
0x402520:       0x0000000000400fa1      0x0000000000400fa8
0x402530:       0x0000000000400faf      0x0000000000400fb6
```
이 phase에서는 input에서 `"%d %d"` 형식으로 int 2개를 받아서 비교하는 방식을 사용한다.  
입력 받은 숫자는 스택(`rsp+0x8`, `rsp+0xc`)에 순서대로 저장되어 있으며, 그 값을 eax에 저장하여 `0x402500`에 있는 주소 배열을 통해 조건을 검사하는 switch문이 있다.  
이때 각 주소는 eax에 값을 설정하고 `*phase_3 + 123`으로 jmp하는 코드이므로, 첫 번째 숫자는 0-7의 숫자란 것을 알 수 있다.  
이후 eax에 설정된 값은 두 번째 입력 받은 값(`rsp + 0x8`)과 비교된다.  
이떄 서로 같다면 성공이므로, 0-7과 eax 할당된 값 쌍 8종 중 아무거나 입력하면 된다.

### Phase 4

#### Input Solution

> `7 7`

> `7 7 DrJisungPark` (`secret_phase`에서 설명할 예정)

#### Pseudocode

```py
a, b = map(int, input().split())
if a > 14: explode_bomb()

def func4(n, low, high):
    mid = (low + high) // 2
    
    if n < mid:
        return mid + func4(n, low, mid - 1)
    elif n > mid:
        return mid + func4(n, mid + 1, high)

    return mid

result = func4(a, 0, 14)
if result != 7 or b != 7:
    explode_bomb()
```

#### Analyze

```asm
Dump of assembler code for function phase_4:
0x0000000000401011 <+0>:     sub    rsp,0x18
0x0000000000401015 <+4>:     lea    rcx,[rsp+0x8]
0x000000000040101a <+9>:     lea    rdx,[rsp+0xc]
0x000000000040101f <+14>:    mov    esi,0x4027cd
0x0000000000401024 <+19>:    mov    eax,0x0
0x0000000000401029 <+24>:    call   0x400c30 <__isoc99_sscanf@plt>
0x000000000040102e <+29>:    cmp    eax,0x2
0x0000000000401031 <+32>:    jne    0x40103a <phase_4+41>
0x0000000000401033 <+34>:    cmp    DWORD PTR [rsp+0xc],0xe
0x0000000000401038 <+39>:    jbe    0x40103f <phase_4+46>
0x000000000040103a <+41>:    call   0x401554 <explode_bomb>
0x000000000040103f <+46>:    mov    edx,0xe
0x0000000000401044 <+51>:    mov    esi,0x0
0x0000000000401049 <+56>:    mov    edi,DWORD PTR [rsp+0xc]
0x000000000040104d <+60>:    call   0x400fde <func4>
0x0000000000401052 <+65>:    cmp    eax,0x7
0x0000000000401055 <+68>:    jne    0x40105e <phase_4+77>
0x0000000000401057 <+70>:    cmp    DWORD PTR [rsp+0x8],0x7
0x000000000040105c <+75>:    je     0x401063 <phase_4+82>
0x000000000040105e <+77>:    call   0x401554 <explode_bomb>
0x0000000000401063 <+82>:    add    rsp,0x18
0x0000000000401067 <+86>:    ret
...
```
```
gef➤  x/s 0x4027cd
0x4027cd:       "%d %d"
```
이 phase에서는 input에서 `"%d %d"` 형식으로 int 2개를 받아서 비교하는 방식을 사용한다.  
각 int는 스택(`rsp+0x8`, `rsp+0xc`)에 저장되고, 첫 번째 값은 0, 14와 함께 `func4` 함수로 전달되어서 어떤 값을 반환하고, 두 번째 값은 나중에 검사한다.  
이때 반환값과 두 번쨰 값 모두 `7`이어야 한다.

```asm
Dump of assembler code for function func4:
0x0000000000400fde <+0>:     push   rbx
0x0000000000400fdf <+1>:     mov    eax,edx
0x0000000000400fe1 <+3>:     sub    eax,esi
0x0000000000400fe3 <+5>:     mov    ebx,eax
0x0000000000400fe5 <+7>:     shr    ebx,0x1f
0x0000000000400fe8 <+10>:    add    eax,ebx
0x0000000000400fea <+12>:    sar    eax,1
0x0000000000400fec <+14>:    lea    ebx,[rax+rsi*1]
0x0000000000400fef <+17>:    cmp    ebx,edi
0x0000000000400ff1 <+19>:    jle    0x400fff <func4+33>
0x0000000000400ff3 <+21>:    lea    edx,[rbx-0x1]
0x0000000000400ff6 <+24>:    call   0x400fde <func4>
0x0000000000400ffb <+29>:    add    eax,ebx
0x0000000000400ffd <+31>:    jmp    0x40100f <func4+49>
0x0000000000400fff <+33>:    mov    eax,ebx
0x0000000000401001 <+35>:    cmp    ebx,edi
0x0000000000401003 <+37>:    jge    0x40100f <func4+49>
0x0000000000401005 <+39>:    lea    esi,[rbx+0x1]
0x0000000000401008 <+42>:    call   0x400fde <func4>
0x000000000040100d <+47>:    add    eax,ebx
0x000000000040100f <+49>:    pop    rbx
0x0000000000401010 <+50>:    ret
```
`func4`는 재귀 함수이다. 중간에 자기 자신을 호출하는 부분이 존재한다.  
각 arguments는 calling convention에 따라 rdi, rsi, rdx에 각각 저장되었으며, 따라서 초반 eax에 계산되어 저장된 값은 2, 3번째 인자의 정수 평균이다.  
이후 첫 번째 인자와 평균값을 비교하여,
1. 크다면 세 번쨰 인자를 평균 - 1로 설정하고 func4를 호출한 후, 그 값을 첫 번째 인자와 더한 값을 반환한다.
2. 작다면 두 번째 인자를 평균 + 1로 설정하고 func4를 호출한 후, 그 값을 첫 번째 인자와 더한 값을 반환한다.
3. 같다면 그냥 첫 번째 인자의 값을 반환한다.

이때 반환값은 7이어야 하고, 2, 3번째 인자는 각각 0, 14였으므로 평균은 7이다.  
따라서 입력은 7을 주면 된다.

### Phase 5

#### Input Solution

> `5 115`

#### Pseudocode

```py
L = 10, 2, 14, 7, 8, 12, 15, 11, 0, 4, 1, 13, 3, 9, 6, 5

a, b = map(int, input().split())
b &= 0xF

if b == 0xF: explode_bomb()

x = y = 0
while b != 15:
    y += 1
    b = L[b]
    x += b

if y != 15 or a != x: explode_bomb()
```

#### Analyze

```asm
Dump of assembler code for function phase_5:
0x0000000000401068 <+0>:     sub    rsp,0x18
0x000000000040106c <+4>:     lea    rcx,[rsp+0x8]
0x0000000000401071 <+9>:     lea    rdx,[rsp+0xc]
0x0000000000401076 <+14>:    mov    esi,0x4027cd
0x000000000040107b <+19>:    mov    eax,0x0
0x0000000000401080 <+24>:    call   0x400c30 <__isoc99_sscanf@plt>
0x0000000000401085 <+29>:    cmp    eax,0x1
0x0000000000401088 <+32>:    jg     0x40108f <phase_5+39>
0x000000000040108a <+34>:    call   0x401554 <explode_bomb>
0x000000000040108f <+39>:    mov    eax,DWORD PTR [rsp+0xc]
0x0000000000401093 <+43>:    and    eax,0xf
0x0000000000401096 <+46>:    mov    DWORD PTR [rsp+0xc],eax
0x000000000040109a <+50>:    cmp    eax,0xf
0x000000000040109d <+53>:    je     0x4010cb <phase_5+99>
0x000000000040109f <+55>:    mov    ecx,0x0
0x00000000004010a4 <+60>:    mov    edx,0x0
0x00000000004010a9 <+65>:    add    edx,0x1
0x00000000004010ac <+68>:    cdqe
0x00000000004010ae <+70>:    mov    eax,DWORD PTR [rax*4+0x402540]
0x00000000004010b5 <+77>:    add    ecx,eax
0x00000000004010b7 <+79>:    cmp    eax,0xf
0x00000000004010ba <+82>:    jne    0x4010a9 <phase_5+65>
0x00000000004010bc <+84>:    mov    DWORD PTR [rsp+0xc],eax
0x00000000004010c0 <+88>:    cmp    edx,0xf
0x00000000004010c3 <+91>:    jne    0x4010cb <phase_5+99>
0x00000000004010c5 <+93>:    cmp    ecx,DWORD PTR [rsp+0x8]
0x00000000004010c9 <+97>:    je     0x4010d0 <phase_5+104>
0x00000000004010cb <+99>:    call   0x401554 <explode_bomb>
0x00000000004010d0 <+104>:   add    rsp,0x18
0x00000000004010d4 <+108>:   ret
```
```
gef➤  x/s 0x4027cd
0x4027cd:       "%d %d"
gef➤  x/16wd 0x402540
0x402540 <array.3161>:  10      2       14      7
0x402550 <array.3161+16>:       8       12      15      11
0x402560 <array.3161+32>:       0       4       1       13
0x402570 <array.3161+48>:       3       9       6       5
```
이 phase에서는 input에서 `"%d %d"` 형식으로 int 2개를 받아서 스택(`rsp+0x8`, `rsp+0xc`)에 저장 후 비교한다.  
eax에 첫 번째로 받은 값을 할당한 후 `& 0xF` 연산을 해서 저장하고, 그 값을 다시 0xF와 비교하여 0xF와 같다면 폭탄이 터진다.  
아니라면 ecx, edx를 통한 반복문에 진입한다.  
ecx는 accumulator, edx는 counter 역할을 하며, rax는 저장된 배열로부터 값을 받는 역할을 한다.  
rax는 `[rax*4+0x402540]`를 통해 저장된 배열인 `{10, 2, 14, 7, 8, 12, 15, 11, 0, 4, 1, 13, 3, 9, 6, 5}`에 rax를 index로 하여 접근하며, 얻은 값이 15가 될 때까지 반복한다.  
이때 반복하는 동안 ecx는 rax의 값이 계속 더해지며, edx는 한 번 반복할때마다 1씩 증가한다.  
최종적으로 얻어야 하는 값은 edx는 15여야 하며, 그 과정에서 얻은 모든 rax의 합인 ecx에 저장된 값과 두 번째로 입력 받은 값이 같아야 한다.  
15번쨰에 15에 접근해야하므로, 간단하게 역산이 가능하며 따라서 답은 `5 115`이다.

### Phase 6

#### Input Solution

> 6 3 1 4 2 5

#### Pseudocode

```py
nums = list(map(int, input().split()))
assert len(nums) == 6

if (
    any(num > 6 for num in nums) or
    len(set(nums)) < 6
):
    explode_bomb()

class Node:
    def __init__(self, id, val):
        self.id = id
        self.val = val
        self.next = None

node1 = Node(1, 0x24c)
node2 = Node(2, 0x354)
node3 = Node(3, 0x16d)
node4 = Node(4, 0x32e)
node5 = Node(5, 0x379)
node6 = Node(6, 0x11e)

node1.next = node2
node2.next = node3
node3.next = node4
node4.next = node5
node5.next = node6

nodes = []
for i in range(0, 24, 4):
    n = nums[i // 4]
    node = node1
    if n > 1:
        j = 1
        while j < n:
            node = node.next
            j += 1
    
    nodes.append(node)

for n1, n2 in zip(nodes[:-1], nodes[1:]):
    if n1.val > n2.val: explode_bomb()
```

#### Analyze

```asm
Dump of assembler code for function phase_6:
0x00000000004010d5 <+0>:     push   r13
0x00000000004010d7 <+2>:     push   r12
0x00000000004010d9 <+4>:     push   rbp
0x00000000004010da <+5>:     push   rbx
0x00000000004010db <+6>:     sub    rsp,0x58
0x00000000004010df <+10>:    lea    rsi,[rsp+0x30]
0x00000000004010e4 <+15>:    call   0x40158a <read_six_numbers>
0x00000000004010e9 <+20>:    lea    r13,[rsp+0x30]
0x00000000004010ee <+25>:    mov    r12d,0x0
0x00000000004010f4 <+31>:    mov    rbp,r13
0x00000000004010f7 <+34>:    mov    eax,DWORD PTR [r13+0x0]
0x00000000004010fb <+38>:    sub    eax,0x1
0x00000000004010fe <+41>:    cmp    eax,0x5
0x0000000000401101 <+44>:    jbe    0x401108 <phase_6+51>
0x0000000000401103 <+46>:    call   0x401554 <explode_bomb>
0x0000000000401108 <+51>:    add    r12d,0x1
0x000000000040110c <+55>:    cmp    r12d,0x6
0x0000000000401110 <+59>:    jne    0x401119 <phase_6+68>
0x0000000000401112 <+61>:    mov    esi,0x0
0x0000000000401117 <+66>:    jmp    0x40115b <phase_6+134>
0x0000000000401119 <+68>:    mov    ebx,r12d
0x000000000040111c <+71>:    movsxd rax,ebx
0x000000000040111f <+74>:    mov    eax,DWORD PTR [rsp+rax*4+0x30]
0x0000000000401123 <+78>:    cmp    DWORD PTR [rbp+0x0],eax
0x0000000000401126 <+81>:    jne    0x40112d <phase_6+88>
0x0000000000401128 <+83>:    call   0x401554 <explode_bomb>
0x000000000040112d <+88>:    add    ebx,0x1
0x0000000000401130 <+91>:    cmp    ebx,0x5
0x0000000000401133 <+94>:    jle    0x40111c <phase_6+71>
0x0000000000401135 <+96>:    add    r13,0x4
0x0000000000401139 <+100>:   jmp    0x4010f4 <phase_6+31>
0x000000000040113b <+102>:   mov    rdx,QWORD PTR [rdx+0x8]
0x000000000040113f <+106>:   add    eax,0x1
0x0000000000401142 <+109>:   cmp    eax,ecx
0x0000000000401144 <+111>:   jne    0x40113b <phase_6+102>
0x0000000000401146 <+113>:   jmp    0x40114d <phase_6+120>
0x0000000000401148 <+115>:   mov    edx,0x6042f0
0x000000000040114d <+120>:   mov    QWORD PTR [rsp+rsi*2],rdx
0x0000000000401151 <+124>:   add    rsi,0x4
0x0000000000401155 <+128>:   cmp    rsi,0x18
0x0000000000401159 <+132>:   je     0x401170 <phase_6+155>
0x000000000040115b <+134>:   mov    ecx,DWORD PTR [rsp+rsi*1+0x30]
0x000000000040115f <+138>:   cmp    ecx,0x1
0x0000000000401162 <+141>:   jle    0x401148 <phase_6+115>
0x0000000000401164 <+143>:   mov    eax,0x1
0x0000000000401169 <+148>:   mov    edx,0x6042f0
0x000000000040116e <+153>:   jmp    0x40113b <phase_6+102>
0x0000000000401170 <+155>:   mov    rbx,QWORD PTR [rsp]
0x0000000000401174 <+159>:   lea    rax,[rsp+0x8]
0x0000000000401179 <+164>:   lea    rsi,[rsp+0x30]
0x000000000040117e <+169>:   mov    rcx,rbx
0x0000000000401181 <+172>:   mov    rdx,QWORD PTR [rax]
0x0000000000401184 <+175>:   mov    QWORD PTR [rcx+0x8],rdx
0x0000000000401188 <+179>:   add    rax,0x8
0x000000000040118c <+183>:   cmp    rax,rsi
0x000000000040118f <+186>:   je     0x401196 <phase_6+193>
0x0000000000401191 <+188>:   mov    rcx,rdx
0x0000000000401194 <+191>:   jmp    0x401181 <phase_6+172>
0x0000000000401196 <+193>:   mov    QWORD PTR [rdx+0x8],0x0
0x000000000040119e <+201>:   mov    ebp,0x5
0x00000000004011a3 <+206>:   mov    rax,QWORD PTR [rbx+0x8]
0x00000000004011a7 <+210>:   mov    eax,DWORD PTR [rax]
0x00000000004011a9 <+212>:   cmp    DWORD PTR [rbx],eax
0x00000000004011ab <+214>:   jle    0x4011b2 <phase_6+221>
0x00000000004011ad <+216>:   call   0x401554 <explode_bomb>
0x00000000004011b2 <+221>:   mov    rbx,QWORD PTR [rbx+0x8]
0x00000000004011b6 <+225>:   sub    ebp,0x1
0x00000000004011b9 <+228>:   jne    0x4011a3 <phase_6+206>
0x00000000004011bb <+230>:   add    rsp,0x58
0x00000000004011bf <+234>:   pop    rbx
0x00000000004011c0 <+235>:   pop    rbp
0x00000000004011c1 <+236>:   pop    r12
0x00000000004011c3 <+238>:   pop    r13
0x00000000004011c5 <+240>:   ret
```
```
gef➤  x/12gx 0x6042f0
0x6042f0 <node1>:       0x000000010000024c      0x0000000000604300
0x604300 <node2>:       0x0000000200000354      0x0000000000604310
0x604310 <node3>:       0x000000030000016d      0x0000000000604320
0x604320 <node4>:       0x000000040000032e      0x0000000000604330
0x604330 <node5>:       0x0000000500000379      0x0000000000604340
0x604340 <node6>:       0x000000060000011e      0x0000000000000000
```
`read_six_numbers`로 스택에 6개 숫자를 입력받고, 숫자를 통해 LinkedList를 조작하는 함수이다.  
이 함수는 총 네 개의 반복문으로 구성되어있다.

첫 번째는 원소들의 조건을 검사하는 반복문이다.  
초기에 r13은 스택에 저장된 6개 수 배열 주소를 가지고, 반복될 때마다 하나씩 eax에 할당하며, r12d가 counter 역할을 한다.  
이떄 eax에 1을 뺀 값이 5보다 큰 지를 검사하며, 크다면 explode_bomb가 실행된다. 만약 작다면 한 번의 반복문이 더 실행된다.  
이 반복문에서는 현재 r12d의 값을 counter인 ebx에 저장하여 현재 원소의 index를 얻어 그 다음 index부터 끝까지 접근해 현재 원소 기준으로 뒤쪽에 있는 원소들 중 중복되는 값이 있는지 검사한다.  
있다면 explode_bomb하므로 원소들은 겹치지 않아야하며, 이 반복문에서 ebx가 5 이상이 된다면 종료되어 eax의 값을 1 늘려 다음 원소로 접근한 후 반복한다.  
즉, 여기서 얻을 수 있는 원소들의 조건은, 6 이하의 겹치치 않는 6개의 정수라는 것이다.

두 번쨰는 LinkedList를 저장하는 반복문이다.  
초기에 esi는 counter, ecx는 counter에 따라 입력 받은 원소들을 할당받는다.  
이때 ecx의 값이 1 이하라면 edx에 0x6042f0가 할당된다.
만약 아니라면 eax에 1이, edx에 0x6042f0가 할당되고, eax가 counter로 다시 반복문에 진입한다.  
해당 반복문은 rdx에 저장된 주소에서 8 바이트 이후에 저장된 값을 재할당하면서 eax의 값을 1씩 증가시킨다. 이때 eax가 ecx의 값과 같아지면 반복문은 종료된다.  
내부 반복문에서 얻은 rdx의 값은 `rsp+rsi*2`에 저장되며, rsi는 현재 counter이기에 스택에 배열로 특정 주소들을 저장하고 있다는 것을 알 수 있다.

이떄 `0x6042f0`에 저장된 값이 무엇인지 분석할 수 있다.  
위의 출력 결과를 보면, 해당 주소에는 node1 - node6가 저장되어 있으며, 각 node들은 크게 3 부분으로 구성되는 듯 보인다.  
1. id 부분, 첫 4바이트
2. value 부분, 그 다음 4바이트
3. next 부분, 다음 node를 가리키는 주소를 저장하는 8바이트 공간
정리하자면, 이 node는 struct로 id, value, next를 저장하는 전형적인 LinkedList의 형태를 띄고 있으며, 순서대로 서로를 가리키고 있다.  
그러므로 두 번째 내부 반복문에서 "저장된 주소의 8바이트 이후 값"을 가져온다는 것은 다음 노드의 주소를 가져온다는 뜻이며, 이는 결국 입력 값이 만약 3이라면 node3을 가져오겠다는 말과 같다.  
이후 이를 순서대로 배열에 저장하므로, 1 - 6을 입력 받은 후 그 순서대로 node를 배열에 저장한다는 뜻이다.

세 번째는 입력 값과 아까 저장된 node 배열을 사용하는 반복문이다.  
초기에 rdx는 rax(=node 배열 + 1)의 주소를 받고, rcx는 rbx(=node 배열)의 값읗 받는다.  
이후 rcx는 node에 접근하여 8바이트 이후 주소에 rax의 주소를 저장한다.  
rax는 다음 node로 접근하기 위해 8바이트 증가하고, 이후 다시 rcx는 rdx의 값을 받아 반복한다.  
만약 rax가 입력값 주소(node 배열 다음 데이터)와 같아진다면 끝났다는 것을 의미하므로 종료한다.  
이 반복문은 저장된 순서대로 node의 next 주소를 재조합하여 LinkedList를 정렬한다.

마지막은 LinkedList 내부 값의 비교를 하는 반복문이다.  
초기에 ebp는 5가 저장되는 counter이며, ebp가 0이 되면 종료한다.  
rbx에는 root node의 주소가 할당되며, rax에는 rbx 주소에서 8 바이트 떨어진 주소, 즉 node의 next node의 주소가 할당된다.  
이 이후 각 노드의 값을 비교한다. 이때 각 rbx가 rax보다 크다면, 즉 수열이 감소한다면 explode_bomb가 작동한다.  
아니라면 ebp를 1 줄이고, rbx의 값을 next node의 주소로 바꾼다.  
여기서 알 수 있는 점은 최종 LinkedList가 오름차순으로 정렬되어 있어야 한다는 것이다.

각 노드의 값은 0x24c, 0x354, 0x16d, 0x32e, 0x379, 0x11e이다.  
노드는 입력한 숫자 순서대로 정렬되므로, 작은 node 번호부터 나열해야한다.  
따라서 이 때의 답은 `6 3 1 4 2 5`이다.

### Secret Phase

#### Input Solution

> `35`

#### Pseudocode

```py
def fun7(tree, i, number):
    if i >= len(tree): return -1

    N = tree[i]
    if N > number:
        return 2 * fun7(tree, 2 * i + 1, number)
    elif N < number:
        return 2 * fun7(tree, 2 * i + 2, number) + 1
    else:
        return 0

TREE = [0x24, 0x8, 0x32, 0x6, 0x16, 0x2d, 0x6b, 0x1, 0x7, 0x14, 0x23, 0x28, 0x2f, 0x63, 0x3e9]
# 실제로는 배열이 아니지만 편의상 배열로 pseudocode를 짬
n = int(input())
if n > 1001: explode_bomb()
if fun7(TREE, 0, n) != 6: explode_bomb()
```

#### Analyze

이 phase는 일반적으로는 접근할 수 없다. 그러나 phase_defused를 관찰하면 발견할 수 있다.

```asm
Dump of assembler code for function phase_defused:
...
0x0000000000401718 <+38>:    mov    esi,0x402817
0x000000000040171d <+43>:    mov    edi,0x6048b0
0x0000000000401722 <+48>:    mov    eax,0x0
0x0000000000401727 <+53>:    call   0x400c30 <__isoc99_sscanf@plt>
0x000000000040172c <+58>:    cmp    eax,0x3
0x000000000040172f <+61>:    jne    0x401762 <phase_defused+112>
0x0000000000401731 <+63>:    mov    esi,0x402820
0x0000000000401736 <+68>:    lea    rdi,[rsp+0x10]
0x000000000040173b <+73>:    call   0x4012ee <strings_not_equal>
0x0000000000401740 <+78>:    test   eax,eax
0x0000000000401742 <+80>:    jne    0x401762 <phase_defused+112>
...
0x000000000040175d <+107>:   call   0x401204 <secret_phase>
...
```
```
gef➤  x/s 0x402817
0x402817:       "%d %d %s"
gef➤  x/s 0x6048b0
0x6048b0 <input_strings+240>:   "7 7"
gef➤  x/s 0x402820
0x402820:       "DrJisungPark"
```
아까 분석했듯이 0x6048b0 부분에 `%s`에 특정 문자열을 넣어야지만 `secret_phase`로 넘어갈 수 있다.  
`*phase_defused + 43`에 breakpoint를 걸고 살펴보면 `<input_strings+240>` 부분에는 `7 7`이 저장되어 있음을 알 수 있다.  
이때 `7 7`은 문제 4번의 답이었으므로 아까 분석과 맞게 4번째 답이 곧 `0x6048b0`에 저장된 값이라고 볼 수 있다.  
`secret_phase` 접근을 위해서는 `"DrJisungPark"`이라는 특정 문자열을 입력해야하고, 4번 문제의 format은 `%d %d`였기 때문에 그냥 `7 7` 뒤에 필요한 문자열을 한 칸 띄워서 입력하면 `%s` 부분에서 문자열을 입력할 수 있다.  
따라서 4번 문제에서 답을 `7 7`이 아닌 `7 7 DrJisungPark`이라고 하면 `secret_phase`에 진입할 수 있다.

```asm
Dump of assembler code for function secret_phase:
0x0000000000401204 <+0>:     push   rbx
0x0000000000401205 <+1>:     call   0x4015cc <read_line>
0x000000000040120a <+6>:     mov    edx,0xa
0x000000000040120f <+11>:    mov    esi,0x0
0x0000000000401214 <+16>:    mov    rdi,rax
0x0000000000401217 <+19>:    call   0x400c00 <strtol@plt>
0x000000000040121c <+24>:    mov    rbx,rax
0x000000000040121f <+27>:    lea    eax,[rax-0x1]
0x0000000000401222 <+30>:    cmp    eax,0x3e8
0x0000000000401227 <+35>:    jbe    0x40122e <secret_phase+42>
0x0000000000401229 <+37>:    call   0x401554 <explode_bomb>
0x000000000040122e <+42>:    mov    esi,ebx
0x0000000000401230 <+44>:    mov    edi,0x604110
0x0000000000401235 <+49>:    call   0x4011c6 <fun7>
0x000000000040123a <+54>:    cmp    eax,0x6
0x000000000040123d <+57>:    je     0x401244 <secret_phase+64>
0x000000000040123f <+59>:    call   0x401554 <explode_bomb>
0x0000000000401244 <+64>:    mov    edi,0x4024d8
0x0000000000401249 <+69>:    call   0x400b40 <puts@plt>
0x000000000040124e <+74>:    call   0x4016f2 <phase_defused>
0x0000000000401253 <+79>:    pop    rbx
0x0000000000401254 <+80>:    ret
```
이 함수의 동작 자체는 간단하다.  
추가로 한 줄을 받은 후 받은 문자열을 십진수로 전환하고, 그 값이 `1001`보다 크다면 폭탄을 터뜨린다.  
만약 그렇지 않다면 `0x604110`과 입력 받은 숫자를 인자로 주어 `fun7` 함수의 반환값을 받은 후 값을 비교한다.  
만약 6이라면 성공이고, 아니라면 폭탄이 터진다.

```asm
Dump of assembler code for function fun7:
0x00000000004011c6 <+0>:     sub    rsp,0x8
0x00000000004011ca <+4>:     test   rdi,rdi
0x00000000004011cd <+7>:     je     0x4011fa <fun7+52>
0x00000000004011cf <+9>:     mov    edx,DWORD PTR [rdi]
0x00000000004011d1 <+11>:    cmp    edx,esi
0x00000000004011d3 <+13>:    jle    0x4011e2 <fun7+28>
0x00000000004011d5 <+15>:    mov    rdi,QWORD PTR [rdi+0x8]
0x00000000004011d9 <+19>:    call   0x4011c6 <fun7>
0x00000000004011de <+24>:    add    eax,eax
0x00000000004011e0 <+26>:    jmp    0x4011ff <fun7+57>
0x00000000004011e2 <+28>:    mov    eax,0x0
0x00000000004011e7 <+33>:    cmp    edx,esi
0x00000000004011e9 <+35>:    je     0x4011ff <fun7+57>
0x00000000004011eb <+37>:    mov    rdi,QWORD PTR [rdi+0x10]
0x00000000004011ef <+41>:    call   0x4011c6 <fun7>
0x00000000004011f4 <+46>:    lea    eax,[rax+rax*1+0x1]
0x00000000004011f8 <+50>:    jmp    0x4011ff <fun7+57>
0x00000000004011fa <+52>:    mov    eax,0xffffffff
0x00000000004011ff <+57>:    add    rsp,0x8
0x0000000000401203 <+61>:    ret
```
```
gef➤  x/60gx 0x604110
0x604110 <n1>:          0x0000000000000024      0x0000000000604130
0x604120 <n1+16>:       0x0000000000604150      0x0000000000000000
0x604130 <n21>:         0x0000000000000008      0x00000000006041b0
0x604140 <n21+16>:      0x0000000000604170      0x0000000000000000
0x604150 <n22>:         0x0000000000000032      0x0000000000604190
0x604160 <n22+16>:      0x00000000006041d0      0x0000000000000000
0x604170 <n32>:         0x0000000000000016      0x0000000000604290
0x604180 <n32+16>:      0x0000000000604250      0x0000000000000000
0x604190 <n33>:         0x000000000000002d      0x00000000006041f0
0x6041a0 <n33+16>:      0x00000000006042b0      0x0000000000000000
0x6041b0 <n31>:         0x0000000000000006      0x0000000000604210
0x6041c0 <n31+16>:      0x0000000000604270      0x0000000000000000
0x6041d0 <n34>:         0x000000000000006b      0x0000000000604230
0x6041e0 <n34+16>:      0x00000000006042d0      0x0000000000000000
0x6041f0 <n45>:         0x0000000000000028      0x0000000000000000
0x604200 <n45+16>:      0x0000000000000000      0x0000000000000000
0x604210 <n41>:         0x0000000000000001      0x0000000000000000
0x604220 <n41+16>:      0x0000000000000000      0x0000000000000000
0x604230 <n47>:         0x0000000000000063      0x0000000000000000
0x604240 <n47+16>:      0x0000000000000000      0x0000000000000000
0x604250 <n44>:         0x0000000000000023      0x0000000000000000
0x604260 <n44+16>:      0x0000000000000000      0x0000000000000000
0x604270 <n42>:         0x0000000000000007      0x0000000000000000
0x604280 <n42+16>:      0x0000000000000000      0x0000000000000000
0x604290 <n43>:         0x0000000000000014      0x0000000000000000
0x6042a0 <n43+16>:      0x0000000000000000      0x0000000000000000
0x6042b0 <n46>:         0x000000000000002f      0x0000000000000000
0x6042c0 <n46+16>:      0x0000000000000000      0x0000000000000000
0x6042d0 <n48>:         0x00000000000003e9      0x0000000000000000
0x6042e0 <n48+16>:      0x0000000000000000      0x0000000000000000
```
이 함수도 재귀함수이다. 이때 첫 번째 인자가 없다면 -1을 반환하고, 있다면 두 번쨰 인자와 비교한다.  
calling convention에 따라 rdi, rsi에 각각 인자가 있으며, rdi에는 특정 주소가 저장되어 있다.  
이때 만약 그 주소에 저장된 값이 rsi보다 크다면 `rdi + 8`에 있는 주소를 첫 번째 인자로 바꾸어 fun7를 재호출 한 후 그 반환값의 두 배를 다시 반환한다.  
만약 rsi보다 작다면 이번엔 두 번째 인자는 `rdi + 16`으로 주소를 바꾸어 fun7을 재호출 한 후 반환값의 두 배에 1을 더한 값을 반환한다.  
rsi와 같다면 0을 반환한다.

이때 가장 초기에 인자로 전달된 `0x604110`에 무엇이 저장되어있는지 알아야 한다.  
구조와 이름을 통해 쉽게 예측할 수 있는데, 이는 이진 트리이다.  
첫 번째 8바이트는 값, 두, 세번째 8바이트는 left, right child의 주소이다.  
이를 그래프로 표현하면 다음과 같다.

<p align="center"><img src="graph.png" alt="Constraint Graph Image" width="100%" style="margin: 0 auto"></p>

이때 다시 재귀함수를 설명한다면, 다음과 같다.
1. rdi > rsi: return 2 * fun7(left_child, n)
2. rdi < rsi: return 2 * fun7(right_child, n) + 1
3. rdi == rsi: return 0

다만 중요한 점은 이 함수의 반환값은 트리에 저장된 값과는 전혀 상관이 없다.  
최종 답이 6이 되어야 한다는 것은 곳 특정한 path를 따라가야 한다는 것을 의미한다.  
6은 짝수이므로, 그 전에는 반드시 rdi > rsi여야 한다. 그 전에는 3이므로 rdi < rsi이여야 하고, 그 전은 1이여야 하기 떄문에 rdi < rsi여야 한다.  
이렇게 되면 총 4개의 node를 거치므로 특정 path를 알 수 있다. 순서대로 정렬하면 다음과 같다:
`left -> right -> equal`
이때 이 순서대로 숫자를 나열하면 `{0x24, 0x8, 0x16, 0x23}`이므로 입력값의 조건을 알 수 있다.  
따라서 답은 0x23이다.