# Data Lab

## Profile

학번: **20240614**  
이름: **이종원**

## Objective

Implements various functions using bitwise operations only.

## Problems

### 1. bitNor

> **~(x|y) using only ~ and &**
```c
int bitNor(int x, int y) {
  return ~x & ~y;
}
```
~(x|y) = ~x & ~y by `De Morgan's Law`

### 2. isZero

> **returns 1 if x == 0, and 0 otherwise**
```c
int isZero(int x) {
  return !x;
}
```
0 implies false and otherwise imply true in C by implicit type conversion of C.

<div style="page-break-after: always;"></div>

### 3. addOK

> **Determine if can compute x+y without overflow**
```c
int addOK(int x, int y) {
  int sign_x = (x >> 31) & 1;
  int sign_y = (y >> 31) & 1;
  int sign_sm = ((x + y) >> 31) & 1;
  return sign_x ^ sign_y | sign_x ^ sign_sm ^ 1;
}
```
Overflow always occurs when two operands have same sign. If the sign of result is different to the sign of operand then the result is overflowed.

### 4. absVal

> **absolute value of x**
```c
int absVal(int x) {
  int mask = x >> 31;
  return (x ^ mask) + (mask & 1);
}
```
If x is negative, then mask is filled with 1 by arithmetical bitshift. Since the 1's complement is equals to `xor 1`, adding one to the result is the 2's complement.  
If x is positive, then mask is 0. Since 0 is the identity in `xor` operation and `0 & 1` is also 0, so the result is equals to the given x.

### 5. logicalShift
> **shift x to the right by n, using a logical shift**
```c
int logicalShift(int x, int n) {
  return x >> n & ~(1 << 31 >> n << 1);
}
```
The shifted bits must be 0 if it is logical shift.  
So, the mask has the front n zero bits and 32 - n one bits.  
`1 << 31` is negative so `1 << 31 >> n << 1` has the front n one bits.  
Therefore, the 1's complement has the front n zero bits thus the front n bits of result becomes zero if bitwise and operation is applied.
