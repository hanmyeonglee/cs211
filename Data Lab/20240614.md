# Data Lab

## Profile

학번: **20240614**  
이름: **이종원**

## Objective

Implements various functions using bitwise operations only.

## Problems

### 1. bitNor

> **~(x|y) using only ~ and &**
```c
int bitNor(int x, int y) {
  return ~x & ~y;
}
```
~(x|y) = ~x & ~y by `De Morgan's Law`

### 2. isZero

> **returns 1 if x == 0, and 0 otherwise**
```c
int isZero(int x) {
  return !x;
}
```
0 implies false and otherwise imply true in C by implicit type conversion of C.

<div style="page-break-after: always;"></div>

### 3. addOK

> **Determine if can compute x+y without overflow**
```c
int addOK(int x, int y) {
  return !(
    (~(x ^ y) & (x + y ^ x)) >> 31
  );
}
```
Overflow always occurs when two operands have same sign. If the sign of result is different from the sign of operand then the result is overflowed.  
`~(x ^ y)` checks the sign equality of two operands and `(x + y ^ x)` checks the sign inequality of one operand and result.  
If the signs of two operand are diffrent, then `~(x ^ y)` is 0, so the result is 1 without any more check.  
Otherwise, `!(x + y ^ x)`, the sign equality of summation result and one operand, is the result.

### 4. absVal

> **absolute value of x**
```c
int absVal(int x) {
  int mask = x >> 31;
  return (x ^ mask) + (mask & 1);
}
```
If x is negative, then mask is filled with 1 by arithmetical bitshift. Since the 1's complement is equals to `xor 0xFFFFFFFF`, adding one to the result is the 2's complement.  
If x is positive, then mask is 0. Since 0 is the identity in `xor` operation and `0 & 1` is also 0, so the result is equals to the given x.

### 5. logicalShift
> **shift x to the right by n, using a logical shift**
```c
int logicalShift(int x, int n) {
  return x >> n & ~(0x80000000 >> n << 1);
}
```
The shifted bits must be 0 if it is logical shift. So, the mask has the front n zero bits and 32 - n one bits.  
`0x80000000` is negative so `0x80000000 >> n << 1` has the front n one bits.  
Therefore, the 1's complement has the front n zero bits thus the front n bits of result becomes zero if bitwise and operation is applied.