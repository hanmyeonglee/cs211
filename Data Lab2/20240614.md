# Data Lab

## Profile

학번: **20240614**  
이름: **이종원**

## Objective

Implements various functions using bitwise operations only.

## Problems

### 1. negate

> return -x
```c
int negate(int x) {
  return ~x + 1;
}
```
`-x = ~x + 1` according to 2's complement expression

### 2. isLess

> if x < y  then return 1, else return 0
```c
int isLess(int x, int y) {
   int x_sign = x >> 31 & 1;
   int y_sign = y >> 31 & 1;
   int is_xy_sign_diff = x_sign ^ y_sign;
   int diff = x + (~y + 1);
   int diff_sign = diff >> 31 & 1;
   return is_xy_sign_diff & x_sign | ~is_xy_sign_diff & diff_sign;
}
```
x < y is true if `x < 0 and y > 0`, or `x - y < 0`  
to prevent integer overflow, two conditions are required.

<div style="break-after: page;"></div>

### 3. float_abs

> Return bit-level equivalent of absolute value of f for floating point argument f.
```c
unsigned float_abs(unsigned uf) {
  int isNan = ((uf & 0x7f800000) == 0x7f800000) && (uf & 0x7fffff);
  if (isNan) {
    return uf;
  }

  return uf & 0x7fffffff;
}
```
changes sign bit to 0 unless uf is NaN

### 4. float_twice

> Return bit-level equivalent of expression 2*f for floating point argument f.
```c
unsigned float_twice(unsigned uf) {
  unsigned sign = uf & 0x80000000u;
  unsigned exp = uf >> 23 & 0xff;
  unsigned frac = uf & 0x7fffff;

  if (exp == 0xff) {
    return uf;
  }

  if (exp == 0xfe) {
    return sign | 0x7f800000;
  }

  if (exp == 0) {
    frac <<= 1;
    if (frac & 0x800000) {
      exp = 1;
      frac &= 0x7fffff;
    }

    return sign | (exp << 23) | frac;
  }

  return uf + 0x800000;
}
```
To split s, e, f, manages infinity and NaN, and adds 1 to e unless e is 0.  
if e is 0, the default msb is 0 so makes f twice and handles e if rounded.

<div style="break-after: page;"></div>

### 5. float_i2f

> Return bit-level equivalent of expression (float) x
```c
unsigned float_i2f(int x) {
  unsigned sign = 0;
  unsigned exp = 127;
  unsigned frac = 0;

  int n;
  int length = 0;

  if (x == 0) return 0;
  if (x == 0x80000000u) return 0xcf000000;

  if (x < 0) {
    sign = 0x80000000u;
    x = -x;
  }

  n = x;
  while (n) {
    n >>= 1;
    length++;
  }

  exp += length - 1;
  if (length <= 24) {
    frac = x << (24 - length);
  } else {
    int shift = length - 24;
    unsigned fraction = x >> shift;
    unsigned rem = x - (fraction << shift);
    
    int half = 1 << (shift - 1);
    int ceil = (rem > half) | ((rem == half) & (fraction & 1));
    frac = fraction + ceil;
    if (frac >> 24) {
      exp++;
      frac >>= 1;
    }
  }
    
  frac &= 0x7fffff;
  return sign | exp << 23 | frac;
}
```
first, handles special cases that x is 0 or INT_MIN.  
next, calculates bit length of x. based on length, calculates exp and frac.  
if frac has remaining bits, then handles rounding of it.

<div style="break-after: page;"></div>

### 6. float_f2i

> Return bit-level equivalent of expression (int) f for floating point argument f.
```c
int float_f2i(unsigned uf) {
  int OOR = 0x80000000u;

  int sign = uf >> 31 & 1;
  int exp = (uf >> 23 & 0xff) - 0x7f;
  int frac = uf & 0x7fffff | 0x800000;

  if (exp > 30) return OOR;
  if (exp < 0) return 0;

  if (exp >= 23) {
    frac <<= exp - 23;
  } else {
    frac >>= 23 - exp;
  }

  if (sign) frac = -frac;
  return frac;
}
```
if e is greater than 30 then uf is either INT_MIN or Out of Range, however return values are equal.  
if e is less than 0 then uf is 0.  
frac is shifted by the e, and applies sign.